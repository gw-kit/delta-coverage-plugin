package io.gradle.surpsg.deltacoverage.testkit

import org.gradle.api.Action
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.SourceSet
import org.gradle.api.tasks.SourceSetContainer
import org.gradle.api.tasks.WriteProperties
import org.gradle.kotlin.dsl.register
import org.gradle.language.jvm.tasks.ProcessResources
import java.io.File
import java.nio.file.Path
import javax.inject.Inject
import kotlin.io.path.isDirectory
import kotlin.io.path.listDirectoryEntries

abstract class IntellijCoverageTestKitExtension @Inject constructor(
    objects: ObjectFactory,
) {

    @Input
    val testTaskName: Property<String> = objects.property(String::class.java)

    @Input
    val intellijCoverageVersion: Property<String> = objects.property(String::class.java).convention("1.0.744")
}

internal abstract class IntellijCoverageGradleTestKitPlugin : Plugin<Project> {

    override fun apply(project: Project) = project.configurePlugin()

    private fun Project.configurePlugin() {
        val extension: IntellijCoverageTestKitExtension =
            extensions.create("intellijCoverageTestKit", IntellijCoverageTestKitExtension::class.java)

        val intellijAgentDep: Provider<String> = intellijAgentDep(extension.intellijCoverageVersion)
        val intellijAgentConfig = project.configurations.register("intellijCoverageAgentJar")
        dependencies.add(intellijAgentConfig.name, intellijAgentDep)

        val copyIntellijAgentTask = tasks.register<Copy>("intellijCoverageAgent") {
            from(intellijAgentConfig)
            into(
                extension.intellijCoverageVersion.flatMap { agentVersion ->
                    project.layout.buildDirectory.file("coverage-agent/${agentVersion}")
                }
            )
        }

        val binaryCoverageFilePath: Provider<String> = project.layout.buildDirectory.file(
            extension.testTaskName.map { "coverage/${it}.ic" }
        ).map { it.asFile.absolutePath }

        val generateIntellijAgentProperties = tasks.register("generateIntellijAgentProperties") {
            inputs.property("binaryCoverageFile", binaryCoverageFilePath)

            val propertiesFile = "intellij-agent.args"
            val argsFile = temporaryDir.resolve(propertiesFile)

            doLast {
                val includePatterns: Set<String> = project.buildIncludeSourcesPatterns().get()
                argsFile.printWriter().use { pw ->
                    with(pw) {
                        appendLine(binaryCoverageFilePath.get())
                        appendLine(TRACKING_PER_TEST.toString())
                        appendLine(CALCULATE_FOR_UNLOADED_CLASSES.toString())
                        appendLine(APPEND_TO_DATA_FILE.toString())
                        appendLine(LINING_ONLY_MODE.toString())

                        includePatterns.forEach { appendLine(it) }

                        appendLine("-exclude")
                        appendLine("android\\..*")
                        appendLine("com\\.android\\..*")
                        appendLine("org\\.jetbrains\\.kotlin\\.gradle\\..*")
                    }
                }
            }

            outputs.file(argsFile)
        }

        val generateTestKitProperties = tasks.create(
            "generateIntellijCoverageAgentProperties",
            WriteProperties::class.java,
        ) {
            group = "verification"
            description = "Generates gradle.properties with JaCoCo java agent for TestKit"
            comment = "Generated by Intellij Coverage Gradle TestKit Plugin"

            dependsOn(copyIntellijAgentTask, generateIntellijAgentProperties)

            val testKitPropertiesFile = layout.buildDirectory.file("testkit/testkit-gradle.properties")
            destinationFile.set(testKitPropertiesFile)

            val jvmArgs: Provider<String> = copyIntellijAgentTask
                .map {
                    it.outputs.files.singleFile.listFiles().toList().single().absolutePath
                }
                .zip(generateIntellijAgentProperties.map { it.outputs.files.singleFile }) { agentJar, propFile ->
                    sequenceOf(
                        "-javaagent:${agentJar}=${propFile}",
                        ENABLE_TRACING.jvmProp,
                        PRINT_ONLY_ERRORS.jvmProp,
                        IGNORE_STATIC_CONSTRUCTORS.jvmProp,
                        DO_NOT_COUNT_HIT_AMOUNT.jvmProp,
                    ).joinToString(" ")
                }

            property("org.gradle.jvmargs", jvmArgs)
        }

        afterEvaluate {
            val testTaskName = extension.testTaskName.get()
            tasks.named(testTaskName) {
                dependsOn(generateTestKitProperties)
            }

            getSourceSet(testTaskName) {
                tasks.named(processResourcesTaskName, ProcessResources::class.java) {
                    from(generateTestKitProperties)
                }

                configurations.named(runtimeOnlyConfigurationName) {
                    dependencies += dependencyFactory.create(generateTestKitProperties.outputs.files)
                }
            }
        }
    }

    private fun Project.buildIncludeSourcesPatterns(): Provider<Set<String>> {
        return project.rootProject.allprojects.map { proj ->
            proj.getSourceSet("main").map { it.allJava.srcDirs }
        }.fold(
            project.provider<Set<File>> { emptySet() },
            ::merge
        ).map { allSourceFiles ->
            allSourceFiles.asSequence()
                .filter { it.exists() }
                .map { file -> obtainCommonPackage(file) }
                .map { it.toIncludePackageRegex() }
                .toSet()
        }
    }

    private fun Project.getSourceSet(
        name: String,
        configure: Action<SourceSet> = Action {},
    ): NamedDomainObjectProvider<SourceSet> {
        return (extensions.getByName("sourceSets") as SourceSetContainer)
            .named(name, configure)
    }

    private fun <T : Any, C : Iterable<T>> merge(
        first: Provider<out C>,
        second: Provider<out C>
    ): Provider<Iterable<T>> = first.zip(second) { left, right ->
        left + right
    }

    private fun obtainCommonPackage(srcDir: File): String {
        val getSingleChildOrNull: Path.() -> Path? = {
            listDirectoryEntries().singleOrNull()?.takeIf(Path::isDirectory)
        }

        return generateSequence(srcDir.toPath().getSingleChildOrNull()) { currentDir ->
            currentDir.getSingleChildOrNull()
        }
            .map { it.fileName.toString() }
            .joinToString(".")
    }

    private fun String.toIncludePackageRegex(): String {
        return this.replace(".", "\\.") + "\\..*"
    }

    private fun intellijAgentDep(version: Provider<String>): Provider<String> = version.map {
        "org.jetbrains.intellij.deps:intellij-coverage-agent:$it"
    }

    private val String.jvmProp: String
        get() = "-D$this"

    private val TRACKING_PER_TEST = false
    private val CALCULATE_FOR_UNLOADED_CLASSES = false
    private val APPEND_TO_DATA_FILE = true
    private val LINING_ONLY_MODE = false

    private val ENABLE_TRACING = "idea.new.tracing.coverage=true"
    private val PRINT_ONLY_ERRORS = "idea.coverage.log.level=error"
    private val IGNORE_STATIC_CONSTRUCTORS = "coverage.ignore.private.constructor.util.class=true"
    private val DO_NOT_COUNT_HIT_AMOUNT = "idea.coverage.calculate.hits=false"

}
